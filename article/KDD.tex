\documentclass{article}
\usepackage{algorithm}
\usepackage{algorithmic}
\floatname{algorithm}{Procedure}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\newcommand{\cH}{\mathcal{H}}
\input{DataMining.tex}
\begin{document}
%%d : dimension
%%n : number of points
\section{Basic Concepts about Clustering}
\label{sec:BasicConceptsClustering}
Let $d$ be a positive integer and $\RR$ the field of real numbers.
For a set $\Set$ of $n$ points $\vec{p_i}\in \RR^d$, we denote by
$|\Set|$ the number of points of $\Set$. We consider the problem that
we will call  ``$\k$-means globally optimum clustering''.
\begin{definition}
  The ``$\k$-means globally optimum clustering'' is to split  
  $\Set\subset\RR^{d}$ of $n$ points $\vec{p_i}$, $i=1,\ldots, n$ into
  $\k$ disjoint 
  nonempty subsets $\Set_1,\ldots, \Set_{\k}$ called \textit{clusters}
  in such a way that the following expression is minimized:
  \begin{equation*}
    f_{\Set_1,\ldots,\Set_{\k}}(\Set)=\sum_{j=1}^\k \sum_{\vec{p} \in \Set_j}
    \norm{\vec{p}-\vec{q}_j}^2,\quad\text{where }
    \vec{q}_j = \frac{\sum_{\vec{p} \in \Set_j} \vec{p}}{|\Set_j|}.
  \end{equation*}
  $\Set_1,\ldots, \Set_{\k}$ is called an \textit{optimal partition}
  of $\Set.$
\end{definition}
It is well known that, given $\Set$, there always exists
$\vec{q_1},\ldots, \vec{q_k}$ such that the partition defined as,
\begin{equation*}
  \Set_j=\bigcap_{l=1}^{k}\{\vec{p}\in\Set\ :\ 
  \|\vec{p}-\vec{q_j}\|^2\le \|\vec{p}-\vec{q_l}\|^2\},
\end{equation*}
is an optimal partition.\footnote{Using this definition it could be
  that one point belong to more than one clusters. Fortunately, it is
  always possible to solve the ties in a reasonable manner}
Indeed, the common approach to attack this problem is to use 
\textit{Lloyd's heuristic}~\cite{Lloy82}, which was first used
in~\cite{MacQ67} and, under minor modifications, performs quite well
in practice, see~~\cite{arthurVas07,ZhangXia09}.

We will need the following concepts from topology:
\begin{itemize}
\item A  set contained in $\RR^d$  is \textit{convex} if for any
  pair of points within the set, every point in the straight line
  segment that joins them is also within the object.
\item Given a set of points $\Set\subset\RR^{d}$, the convex hull of $\Set$ is the
  smallest set of $\RR^{d}$ which contains $\Set$.
\item   Given $\vec{a}\in\RR^d-\{\vec{0}\}$ and $b\in\RR$, the set 
  $\cH = \{\vec{x}\in\RR^d : \transpose{\vec{a}}\vec{x}=b\}$ is called
  a hyperplane.
\item A point $\vec{p}\in\RR^{d}$ lies in the \textit{left side} of
  hyperplane $\cH$ if $\transpose{\vec{a}}\vec{p}>b$. If 
  $\transpose{\vec{a}}\vec{p} < b$, the point $\vec{p}$ lies  in the
  \textit{right side} of hyperplane $\cH$.
\item An hyperplane $\cH$ \textit{separates} two sets $\Set,\
  \Set'\subset\RR^d$ if all the points in $\Set$ lies in the left side
  of $\cH$ and all the points in $\Set'$ lies in the right side of $\cH$.
\end{itemize}
We cite here  the maximum separation hyperplane.
\begin{lemma}
  \label{lem:maximum_separation}
  For any two convex sets $\Set,\ \Set'\subset \RR^d$ such that $\Set\cap \Set' =
  \emptyset$,  there exists an   hyperplane $\cH$ that separates
  $\Set$ and $\Set'$.
\end{lemma}

As it was stated before, it is known that one optimal partition is defined using
$k$ centroids. Partitions defined by centroid have a very interesting
property.
\begin{lemma}
  Given a set of point $\Set\subset \RR^{d}$ and centroids
  $\vec{q_1},\ldots,\vec{q_k}\in\RR^d$, the partition $\Set_1,\ldots,
  \Set_k$ defined as 
  \begin{equation*}
    \Set_j=\bigcap_{l=1}^{k}\{\vec{p}\in\Set\ :\ 
    \|\vec{p}-\vec{q_j}\|^2\le \|\vec{p}-\vec{q_l}\|^2\},
  \end{equation*}
  for $j = 1,\ldots, k$ satisfies:
  \begin{itemize}
  \item the intersection of the convex hull of any two different
    clusters $\Set_i,\Set_j$ is empty,
  \item for each pair $\Set_i, \Set_j$ exists an hyperplane $\cH$ that 
    separates $\Set_i$ and $\Set_j$.
  \end{itemize}
\end{lemma}
\begin{proof}
  The first assertion of the lemma is proved by induction. For $k=2$,
  it is trivial. The general case is done noting that the intersection
  of two convex sets is a convex set. So, the convex hull of 
  \begin{equation*}
    \Set_j=\bigcap_{l=1}^{k}\{\vec{p}\in\Set\ :\ 
    \|\vec{p}-\vec{q_j}\|^2\le \|\vec{p}-\vec{q_l}\|^2\},
  \end{equation*}
  is just the intersection of the convex hulls of 
  \begin{equation*}
    \{\vec{p}\in\Set\ :\ 
    \|\vec{p}-\vec{q_j}\|^2\le \|\vec{p}-\vec{q_l}\|^2\},
  \end{equation*}
  for $l\neq j$, which are disjoint by induction.

  The second assertion is a direct application of
  Lemma~\ref{lem:maximum_separation} and that $\Set_i, \Set_j$ are
  convex sets. 
\end{proof}

\section{Reverse Enumeration}
\label{sec:reverse_enumeration}
Reverse Enumeration is a method for enumerating element in a set. It
was introduced in~\cite{AvisFukuda} which solves the following
problem,
\begin{problem}
  \label{prob:traversal}
  Suppose that $G = (V, E)$ be an undirected graph, where $V$ is a set
  of vertex and $E$ is the edge set. Enumerate all the elements in $V$. 
\end{problem}
The difficulty of this particular problem lies in the fact that $V$
is  not given explicitly, however given a node $v\in V$ it is possible
to calculate its neighbors.

The problem of graph traversal is well-known, and there are 
well-known algorithms like breadth-first search and depth-first
search, see~\cite[Page 597]{Cormen}. 

Unfortunately, these algorithms needs to mantain a data 
structure with all the nodes that have been visited in order to avoid
looping endlessly because of  cycles in the graph. This implies a big
drawback. % Also, the complexity of these algorithms depends on the
% cardinality of the set of edges, \textbf{instead} of depending only on
% the number of nodes.
  
For introducing a more efficient way of solving
Problem~\ref{prob:traversal} we need to introduce the definition of
\textit{local search}. 
\begin{definition}
  A local search  $(G, R, f)$ is a triple satisfying $R\subset V$, $f$
  is  a mapping $f: V\mapsto V$ with the following properties:
  \begin{itemize}
  \item $(v,f(v))$ is an edge of the graph for $v\in V- R$,
  \item for all $v\in  V- R$, there exists a positive integer $t$ such
    that $f^{t}(v)\in R$.
  \end{itemize}
  The function $f$ is said to be the \textit{local search function}
  and $G$ the \textit{underlaying graph structure}.
\end{definition}
Informally a local search algorithm is a way of explore a
graph in a non systematic way, starting in any candidate and heading
for the set of solutions $R$,  see~\cite[Page 110]{RussellNorvig} for
a more detailed exposition.  

A local search define a subgraph of $G$ called the \textit{trace} $T =
(V, E(f))$ where,
\begin{equation*}
  E(f) = \{(v,f(v)\ :\ v\in V- R\}.
\end{equation*}
An important fact that appear in~\cite[Property 2.1]{AvisFukuda} is
that the trace of any local search contains all the nodes of $G$ and
each component contains only one element of the set $R$ and no
cycles. 

So, most efficient way to output all the component is to traverse all
the components of $T$, starting at every element of $R$. 
However, for a local search function $f$ is normally difficult to find
the preimages of a node $v$. In most of the cases, there is an 
\textit{adjacency oracle} which gives the neighbours of a node. The
original definition can be found in~\cite{AvisFukuda}, but here we
simplify it for our purposes. 
\begin{definition}
  A graph $G$ is given by an  adjacency oracle if there exists  a
  function $Adj$ that takes a node $v$ an return an ordered list of
  neighbors of $v$.
\end{definition}
So, given a graph $G$ given by an adjacency oracle $Adj$ and a local
search $(G,R,f)$, Algorithm~\ref{alg:reverse_enumeration} will output
all the nodes. 
\begin{algorithm}
  \caption{General Reverse Search}
  \label{alg:reverse_enumeration}
  \begin{algorithmic}
    \REQUIRE An adjacency oracle $Adj$, a local search $(G,R,f)$
    \ENSURE all nodes in $V$ without any repetition
    \FORALL{$r\in R$}
    \STATE yield $r$
    \STATE {$i, do, v = 1, True, r$}
    \WHILE{$do$}
    \WHILE{ there are at least $i$ elements in $Adj(v)$}
    \STATE let $Next$ be the $i$th element of $Adj(v)$
    \IF{$f(Next) == v$}
    \STATE $v, i = Next, 0$
    \ELSE
    \STATE { $i = i +1$}
    \ENDIF
    \ENDWHILE
    \IF{$v == r$}
    \STATE{$do = False$}
    \ELSE
    \STATE $u, v, i  = v, f(v), 1$
    \WHILE{$i$th element of $Adj(v)$ is not $u$}
    \STATE $i = i +1$
    \ENDWHILE
    \ENDIF
    \ENDWHILE
    \ENDFOR
  \end{algorithmic}
\end{algorithm}
The complexity of the algorithm is given in~\cite[Theorem
2.2]{AvisFukuda}, which we enunciate here.
\begin{theorem}
  Let   $(G, R, f)$ be a local search where  $G$ is
  given by a adjacency oracle $Adj$. Suppose that  $Adj(v)$ does not
  contain more than $\delta$ nodes for any $v\in V$. Then, if $t(f)$
  and $t(Adj)$ are the times complexity for $f$ and $Adj$,
  respectively, the time complexity of reverse search is of order of
  magnitude, 
  \begin{equation*}
    \delta t(Adj)|V| + t(f)|E|.
  \end{equation*}
\end{theorem}
\bibliographystyle{plain}
\bibliography{bibliography}
\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
